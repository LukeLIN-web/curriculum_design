# 计算机网络

|  OSI 七层  |
|  ----  |
|  Application 应用层  |
| Presentation(五层合并到应用层)表示层 |
| Session 会话层(五层合并到应用层) |
| Transport  传输层 传输层的主要协议有[UDP](https://baike.baidu.com/item/UDP/571511)、TCP，是使用者使用平台和计算机信息网内部数据结合的通道，可以实现数据传输与数据共享； |
| NetWork 网络层  网络层的主要协议有ICMP、IP、IGMP， |
| Data/Link   有以太网 CSMA -CD  或token ring 令牌(用在数据量非常大的地方) |
| Physical(四层合并到数据链路层) |



## 应用层

要协议有http, [Telnet](https://baike.baidu.com/item/Telnet/810597)、[FTP](https://baike.baidu.com/item/FTP/13839)、 电子邮件的  [SMTP](https://baike.baidu.com/item/SMTP/175887)等,万维网的http https ，是用来接收来自传输层的数据.





## 传输层

UDP无连接， 不保证可靠性。

Udp不用给任何确认， 即时通信。

Tcp 面向连接, 可靠， 开销大， 数据单元首部大， 占用许多处理机资源

TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种断点我们叫作套接字（socket），它的定义为端口号拼接到IP地址即构成了套接字，例如，若IP地址为192.3.4.16 而端口号为80，那么得到的套接字为192.3.4.16:80。

1. Tcp： 应用数据被分割成 TCP 认为最适合发送的数据块。
2. TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
3. **校验和：** TCP     将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
4. TCP 的接收端会丢弃重复的数据。
5. **流量控制：** TCP     连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）
6. **拥塞控制：** 当网络拥塞时，减少数据的发送。
7. **ARQ**协议：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
8. **超时重传：** 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

#### **TCP协议的三次握手和四次挥手：**

注：**seq**:"sequance"序列号；**ack**:"acknowledge"确认号；**SYN**:"synchronize"请求同步标志；**ACK**:"acknowledge"确认标志"；**FIN**："Finally"结束标志。

　　**TCP连接建立过程：**首先Client端发送连接请求报文syn  ， Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server 发ACK报文，并分配资源，这样TCP连接就建立了。

　　**TCP连接断开过程：**假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说"我Client端没有数据要发给你了，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。"一次 , 客户端进入fin wait1 , sever进入close wait , 停止接收客户端的data.

所以服务器先发送ACK，告诉Client端，请求收到了，但是服务器还没发完,这个时候Client端就进入FIN_WAIT2状态，继续等待Server端的FIN报文。两次 

当Server端确定数据已发送完成，则向Client端发送FIN报文，"告诉Client端，好了，我这边数据发完了，准备好关闭连接了"。三次, sever进入 last ack 最后确认状态

Client端收到FIN报文后， 怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传ack。Server端收到ACK后，就知道可以断开连接了。Client端等待了2MSL(max segment lifetime)后依然没有收到回复，则证明Server端已正常关闭，四次  

那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！

​    如果请求断开报文没到达，服务器会重发， 那客户端就在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。 另一个是客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文



**为什么要三次握手？**

　　在只有两次“握手”的情形下，假设Client想跟Server建立连接，但是却因为中途连接请求的数据报丢失了，故Client端不得不重新发送一遍；这个时候Server端仅收到一个连接请求，因此可以正常的建立连接。

但是，有时候Client端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下Server端将先后收到2次请求，并持续等待两个Client请求向他发送数据...

问题就在这里，Cient端实际上只有一次请求，而Server端却有2个响应，极端的情况可能由于Client端多次重新发送请求数据而导致Server端最后建立了N多个响应在等待，因而造成极大的资源浪费！所以，“三次握手”很有必要！

**三次握手的过程中会遇到什么攻击**

假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入**大量的数据**。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。

服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是**Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包**，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。

常见的防御 SYN 攻击的方法有如下几种：

- 缩短超时（SYN Timeout）时间
- 增加最大半连接数
- 过滤网关防护
- SYN cookies技术

　　**为什么要四次挥手？**

　　试想一下，假如现在你是客户端你想断开跟Server的所有连接该怎么做？第一步，你自己先停止向Server端发送数据，并等待Server的回复。但事情还没有完，虽然你自身不往Server发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据；故Server端还得终止主动向你发送数据，并等待你的确认。其实，说白了就是保证双方的一个合约的完整执行！

1.1 TCP三次握手和四次挥手的过程

客户端syn,  服务器回复syn/ack, 客户端ack.

客户端 fin , 服务器ack,  服务器fin,  客户端ack



1.2 为什么TCP建立连接需要三次握手,断开连接需要四次挥手

一端(client)A发出去的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。本来这是一个早已失效的报文段，但是B收到此失效的报文之后，会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同意建立连接。

如果不采用“三次握手”，那么只要B端发出确认报文就会认为新的连接已经建立了，但是A端并没有发出建立连接的请求，因此不会去向B端发送数据，**B端没有收到数据就会一直等待**，这样B端就会白白浪费掉很多资源。

如果采用“三次握手”的话就不会出现这种情况，B端收到一个过时失效的报文段之后，向A端发出确认，此时A并没有要求建立连接，所以就不会向B端发送确认，这个时候B端也能够知道连接没有建立。

另一个原因是 : 如果只有两次通信的话，这时候B不确定A是否收到了确认消息，有可能这个确认消息由于某些原因丢了。



**挥手要四次, 因为服务器要继续发送数据完毕, 所以ack和syn分开.**



1.3 TCP四次挥手为什么有Time-Wait过程

1. 尽可能护送最后的ACK达到对端。

2. 让旧四元组对应的所有网络包都消失后（等一段时间）， 才允许新四元组建立.



1.4 TCP如果没有完成第四次挥手会发生什么

服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态.





1.5 TCP第三次握手可以传输数据吗

可以传输数据,此时客户端已经处于ESTABLISHED状态。对于客户端来说，他已经建立起连接了，并且已经知道服务器的接收和发送能力是正常的。所以也就可以携带数据了



### 2. TCP和UDP的区别

tcp 可靠, udp不可靠, udp 开销少, 占用资源少. 



### 3. TCP的可靠传输

3.1 TCP如何确保可靠性传输

自动重传请求ARQ (Automatic Repeat reQuest)。



在发送完一个分组后，必须暂时保留已发送的分 组的副本。 (为了重传)
分组和确认分组都必须进行编号。
超时计时器的重传时间应当比数据在分组传输的 平均往返时间更长一些。a等待了2tao后,  再等待一段时间, 还是没收到确认就重传.

 TCP 连接的每一端都必须设有两个''窗口——一个 发送窗口和一个接收窗口。
 TCP 的可靠传输机制用字节的序号进行控制。TCP 所有的确认都是基于序号而不是基于报文段。



#### 3.2 TCP的拥塞控制

快重传算法首先要求接收方每收到一个失序的报 文段后就立即发出重复确认。这样做可以让发送方及早知道有报文段没有到达接收方。
发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段。
不难看出，快重传并非取消重传计时器，而是在 某些情况下可更早地重传丢失的报文段。

快恢复算法
(1) 当发送端收到连续三个重复的确认时，就执行“ 乘法减小”算法，把慢开始门限 ssthresh 减半。 但接下去不执行慢开始算法。
(2)由于发送方现在认为网络很可能没有发生拥塞， 因此现在不执行慢开始算法，即拥塞窗口 cwnd 现在不设置为 1，而是设置为慢开始门限 ssthresh 减半后的数值，然后开始执行拥塞避免 算法（“加法增大”），使拥塞窗口缓慢地线性 增大。
发送窗口的上限值
发送方的发送窗口的上限值应当取为接收方窗口 rwnd 和拥塞窗口 cwnd 这两个变量中较小的一 个，即应按以下公式确定：
发送窗口的上限值 = Min [rwnd, cwnd]
当 rwnd < cwnd 时，是接收方的接收能力限制发送窗口的最大值。
当 cwnd < rwnd 时，则是网络的拥塞限制发送窗口的最大值。



3.3 TCP传输通信时,[客户端](https://www.nowcoder.com/jump/super-jump/word?word=客户端)突然断开连接,服务端如何判断

3.4 TCP的端口为了区分什么



### 4. 常见的HTTP状态码



### 5. HTTP报文

5.1 HTTP请求报文和响应报文的组成



5.2 HTTP请求报文包含哪些方法, GET和POST的区别





### 6. HTTP和HTTPS的区别



### 7. HTTP1.0和1.1和2.0的区别



### 8. HTTPS密钥交换过程

HTTP报文是包裹在TCP报文中发送的，服务器端收到TCP报文时会解包提取出HTTP报文。但是这个过程中存在一定的风险，HTTP报文是明文，如果中间被截取的话会存在一些信息泄露的风险。那么在进入TCP报文之前对HTTP做一次加密就可以解决这个问题了。HTTPS协议的本质就是HTTP + SSL(or TLS)。在HTTP报文进入TCP报文之前，先使用SSL对HTTP报文进行加密。从网络的层级结构看它位于HTTP协议与TCP协议之间。
HTTPS在传输数据之前需要客户端与服务器进行一个握手(TLS   
Transport Layer Security/SSL握手)，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL使用了非对称加密，对称加密以及hash等。具体过程请参考经典的阮一峰先生的博客[TLS/SSL握手过程](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)。  
HTTPS相比于HTTP，虽然提供了安全保证，但是势必会带来一些时间上的损耗，如握手和加密等过程，是否使用HTTPS需要根据具体情况在安全和性能方面做出权衡。
### SSL Secure Sockets Layer
爱丽丝是客户端， 鲍勃是服务器
第一步，爱丽丝给出协议版本号比如TLS 1.0版、一个客户端生成的随机数（Client random），以及客户端支持的加密方法比如RSA公钥加密。
第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。
第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。
第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret）。
第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成"对话密钥"（session key），用来加密接下来的整个对话过程。
（1）生成对话密钥一共需要三个随机数。
（2）握手之后的对话使用"对话密钥"加密（对称加密），服务器的公钥和私钥只用于加密和解密"对话密钥"（非对称加密），无其他作用。
（3）服务器公钥放在服务器的数字证书之中。
session ID的思想很简单，就是每一次对话都有一个编号（session ID）。如果对话中断，下次重连的时候，只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的"对话密钥"，而不必重新生成一把。
session ID是目前所有浏览器都支持的方法，但是它的缺点在于session ID往往只保留在一台服务器上。所以，如果客户端的请求发到另一台服务器，就无法恢复对话。session ticket就是为了解决这个问题而诞生的，目前只有Firefox和Chrome浏览器支持。



### 9. HTTP的缓存机制





### 10. 输入URL跳转网页的过程

1. dns解析域名，首先本地域名服务器查询，没有， 向root域名服务器， 然后 com顶级域名，com又去问google。com服务器， google。com服务器知道www.google.com对应的ip地址， 发给本地域名服务器，本地域名服务器缓存到本地。  多级缓存：  
2. 发送http请求，同时发送cookie
4. 服务器处理请求
5. 服务器发回html
6. 浏览器解析html



### 11. 计算机网络四层协议,五层协议,七层协议

七层  应用, 表示, 会话, 传输, 网络, 数据链路, 物理层. 

五层 应用,  传输, 网络, 数据链路, 物理层. 

四层 应用,  传输, 网络, 数据链路, 

### 12. 什么是cookie和session,区别是什么, 禁用cookie怎么办

Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息。如何识别特定的客户呢？cookie就可以做到。每次HTTP请求时，客户端都会发送相应的Cookie信息到服务端。它的过期时间可以任意设置，如果你不主动清除它，在很长一段时间里面都可以保留着，即便这之间你把电脑关机了。

在安全性第一的前提下，选择Session更优。重要交互信息比如权限等就要放在Session中，一般的信息记录放Cookie就好了。

Session 的运行依赖Session ID，而 Session ID 是存在 Cookie 中的，也就是说，如果浏览器禁用了 Cookie，Session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 Session ID）。

目前大多数的应用都是用 Cookie 实现Session跟踪的。第一次创建Session时，服务端会通过在HTTP协议中反馈到客户端，需要在 Cookie 中记录一个Session ID，以便今后每次请求时都可分辨你是谁。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？建议使用URL重写技术进行会话跟踪，即每次HTTP交互，URL后面都被附加上诸如 sid=xxxxx 的参数，以便服务端依此识别用户。

### 13. 页面加载不出来的原因



### 14.在浏览器中输入 www.baidu.com 后执行的全部过程

　　现在假设如果我们在客户端（客户端）浏览器中输入http://www.baidu.com,而baidu.com为要访问的服务器（服务器），下面详细分析客户端为了访问服务器而执行的一系列关于协议的操作：

　　1）客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。

　　2）在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。服务器处理请求， 发一个html

　　3）客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。

　　4）客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。

客户端获得 html 文件, 浏览器解析html

## 网络层

把传输层的报文segment 和数据报 ， 封装成分组和包传送。

#### IP协议网络层

##### IP地址

有五类, A到E类, A类是当年定ip地址时的大企业, IBM, Microsoft等, 

浙大有几个class C的地址.浙大没有A类, 但是内部网有假的10.10.0.21作为IP地址,默认没有固定的IP地址.

| A    | 0    | prefix                  | suffix |      |
| :--- | ---- | ----------------------- | ------ | ---- |
| B    | 10   | prefix                  | suffix |      |
| C    | 110  | prefix                  | suffix |      |
| D    | 1110 | multicast address       |        |      |
| E    | 1111 | reserved for future use |        |      |

127.0.0.1 就是自己,不联网也可以ping 通.



##### IP数据包

以太网数据包只包含MAC地址，并没有IP地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？

回答是不需要，我们可以把IP数据包直接放进以太网数据包的"数据"部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。

##### **子网掩码**

我们要判断，这个IP地址是不是在同一个子网络，这就要用到子网掩码。subnet mask.所谓"子网掩码"，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。

子网掩码与运算来判断是不是在一个子网络.

例如:  已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的AND运算（两个数位都为1，结果为1，否则为0），计算结果为192.168.1.0；然后对Google的IP地址172.194.72.105也做一个AND运算，计算结果为172.194.72.0。这两个结果不相等，所以结论是，Google与本机不在同一个子网络。

因此，我们要向Google发送数据包，必须通过网关192.168.1.1转发，也就是说，接收方的MAC地址将是网关的MAC地址。

##### 动态IP地址

所谓"动态IP地址"，指计算机开机后，会自动分配到一个IP地址，不用人为设定。它使用的协议叫做DHCP协议。首先，它是一种应用层协议，建立在UDP协议之上.

这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做"DHCP服务器"。新的计算机加入网络，必须向"DHCP服务器"发送一个"DHCP请求"数据包，申请IP地址和相关的网络参数。

前面说过，如果两台计算机在同一个子网络，必须知道对方的MAC地址和IP地址，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？

（1）最前面的"以太网标头"，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。 每一个网卡出厂时都有一个MAC地址.

（2）后面的"IP标头"，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。

（3）最后的"UDP标头"，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。

这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道"这个包是发给我的"，而其他计算机就可以丢弃这个包。

接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个"DHCP响应"数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。

新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。

##### VLAN

192.168.2.1

192.168.1.1

192.168.1.0 是网络地址, 0.0.0.1 是主机地址. 24位子网掩码就在不同网段, 需要三层交换机/ 路由器作为网关,   主机- > 网关- > 网关-> 主机 

如果用16位子网掩码, 就在同一个网段,  可以网线直连, 二层交换机连在同一个VLAN里. 

VLAN和VLAN 单臂路由.

#### ARP表  



## 数据链路层

以太网, 数据链路层，主要协议有ARP、[RARP](https://baike.baidu.com/item/RARP/610685)，主要功能是提供链路管理错误检测、对不同通信媒介有关信息细节问题进行有效处理等. 

在两个相邻节点之间传送数据时，**数据链路层将网络层交下来的 IP 数据报组装成帧**，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。

在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。 控制信息还使接收端能够检测到所收到的帧中有无差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。

