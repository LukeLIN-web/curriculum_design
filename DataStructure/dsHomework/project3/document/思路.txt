 首先把每个服务器排好,根据时 ,然后分, 然后秒 ,
然后再把服务器开始的时间排好. 你要找最长,那就先看最早开始的时间a, 下一个服务器有没有在a结束之前开始,
 如果有, 那就看所有的服务器有没有在b结束之前开始, 直到没有服务器在x结束前开始. 记录maxtime.
然后看第二早开始的服务器, 
然后如果服务器的开始时间到24:00 小于maxtime, 那就return,

哪些时间开始
首先把读入存成秒
如果大于maxtime 那就是0 .

序列法. 
 *  首先把每个服务器排好,根据时 ,然后分, 然后秒 ,然后  再把服务器开始的时间排好. 你要找最长,那就先看最早开始的时间a, 下一个有没有在a结束之前开始,
 *序列法.
 *把序列加起来.然后重复的, 放在第二排, 注意重叠部分两排都有
那么,怎么判断重复呢? 如果b开始<a开始的时间< b结束 就是重复.
还有重复的, 放在第三排.
然后判断, 就第一排长度 - 这个, 第二排长度-这个



这题不用这么麻烦重叠起来.
 就遍历, 第一个, 第一个a结束,如果有别的b, 那就temptime+= bstat-astat
然后同样循环下一个. 
如果没有, 那就maxtime = aend- astat;
再循环b. 算法应该是nlogn的 

 how to deal with switch from different servers?  怎么找别的b?
先找到最早的,
可以用set? 然后看第二个时间. 因为第一个服务器的时间保证不会是第二个的开始.
可以先用mapsort每个服务器, 然后放在set中. map就是为了整理每一个服务器.
class{ name, start, end } b就是下一个.
事实上在set中不需要区分服务器,  我们可以先存一下,然后看看能不能不用name.
看itnext结束的时间, 如果itnext结束的时间