
序列法. 
 *  首先把每个服务器排好,根据时 ,然后分, 然后秒 ,然后  再把服务器开始的时间排好. 你要找最长,那就先看最早开始的时间a, 下一个有没有在a结束之前开始,
 *序列法.
 *把序列加起来.然后重复的, 放在第二排, 注意重叠部分两排都有
那么,怎么判断重复呢? 如果b开始<a开始的时间< b结束 就是重复.
还有重复的, 放在第三排.
然后判断, 就第一排长度 - 这个, 第二排长度-这个

这题不用这么麻烦重叠起来.

 首先把每个服务器排好放在map中,根据时 ,然后分, 然后秒 ,mapsort每个服务器
 然后放在set中. map就是为了整理每一个服务器.
事实上在set中不需要区分服务器name, 
然后再把服务器开始的时间排好. 因为第一个服务器的时间保证不会是自己下一个重复.
你要找最长,那就先看最早开始的时间it, 
how to process the itnext结束早于it,开始晚于it? directly add in vector
how to process the itnext结束晚于it,开始晚于it? link them
具体实现是:
如果it 包含itnext, 那就itnext加入到block中.然后itnext++;
直到没有包含,看下一个服务器有没有在it结束之前开始,
 如果有, 说明itnext连着it, 那就temptime+= itnextstat-itstat.
然后it= itnext,itnext++;继续遍历,下一个服务器有没有在it结束之前开始, 直到没有服务器在it结束前开始. 
最后如果没有连着, 那就 temptime +=it的长度.再加入到vector中

算法应该是nlogn的 


看itnext结束的时间, 如果itnext结束的时间

问题, 遍历每一个吗? 怎么遍历?
如果遍历每一个, 那很可能就重复了, 因为link的后面重复计算了. 所以必须移动it.

 
不需要每次query都遍历, 只需要遍历一次, 把它分成块, 然后和每一块比较即可.
最大的也不用单独算了, 节省了16行代码